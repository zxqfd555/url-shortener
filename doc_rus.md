# Постановка задачи

Необходимо разработать сокращалку URL-ов (как t.co или goo.gl). Должны быть поддержаны следующие функции:

  - Добавить ссылку. Для нее необходимо вернуть сокращенный URL, то есть URL вида "sh.co/shrt". Для ссылки задается время, которое она живет на сервере с момента последнего доступа.
  - Проследовать по сокращенной ссылке. Необходимо перенаправить пользователя по актуальному URL-у, либо вернуть 404 если ссылки нет, либо она была удалена вследствие протухания.

# API

Два endpoint-а.

Подход: недо-REST. От REST мы возьмем глаголы в методе запроса, statelessness. HATEOAS как "карту" методов API реализовывать не будем, так как оно достаточно простое.

## Добавить сокращенную ссылку

POST `/link`
Тело запроса - JSON с полями:
  - `"url"` -- адрес ссылки;
  - `"timeout"` -- гарантированное время жизни ссылки после добавления или последнего доступа к ней (whatever happens last) в секундах.

Варианты ответа:
  - Успех. Код 201, в заголовке `Location` - сокращенный URL, вместе с хостом (то есть, например: "sh.co/shrt").
  - Плохой формат запроса. Код 400. Если в JSON-е в теле нет поля `"url"` или `"timeout"`.

## Проследовать по сокращенной ссылке

GET `/<slug>`

Варианты ответа:

  - Успех. Код 301, в заголовке `Location` - реальный URL. То есть, перенаправление по актуальному URL-у.
  - Такой ссылки нет. Код 404. Это могло случиться по двум причинам: по этой ссылке никогда ничего и не было или же истек дедлайн с времени последнего доступа.

# CAP

Будем целиться в CP-гарантии. Мотивация: когда пользователь сокращает ссылку, он зачастую сразу хочет поделиться ей с кем-то. Поэтому важно, чтобы по сокращенной ссылке доступ был сразу же.

С другой стороны, мы не будем пытаться добиться того, чтобы ссылка исчезала в точности после выставленного дедлайна. Мы разрешим ссылке жить еще недолго после протухания, давая гарантию лишь на то, что если не было окна длиной в TTL, в котором обращений по ссылке не было, то ссылка всегда будет не в удаленном состоянии. Если такое окно уже прошло, а ссылку мы удалить не успели, и по ней походили, то мы все также будем стараться ее продлить, однако 100%-гарантий уже не дается. Позже покажем, что это решение имеет модель консистентности eventual consistency.

Дальше рассмотрим два решения, из которых возьмем второе.
В качестве БД для хранения отображения "slug -> real link" возьмем MongoDB, настроенную на CP-гарантии с использованием механизма консенсусов.
